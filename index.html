<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socratic-Quantum Forge: Studio Simulator</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ecf0f1;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        h1 {
            color: #e67e22;
            text-shadow: 1px 1px 2px #000;
            margin-bottom: 20px;
        }
        #simulationContainer {
            position: relative; /* This is key for positioning the input field */
            width: 1280px;
            height: 720px;
        }
        canvas {
            background-color: #2c3e50;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: default;
        }
        .command-bar {
            position: absolute;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #commandInput {
            background-color: #ecf0f1;
            color: #2c3e50;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
            padding: 10px;
            box-sizing: border-box;
        }
        #commandInput:focus {
            outline: 2px solid #3498db;
        }
        .sim-button {
             background-color: #3498db;
             color: white;
             border: none;
             border-radius: 4px;
             padding: 10px 15px;
             font-size: 14px;
             cursor: pointer;
             transition: background-color 0.2s;
        }
        .sim-button:hover {
            background-color: #5dade2;
        }
        #controls {
            margin-top: 20px;
            padding: 15px;
            background-color: #2c3e50;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        #toggleSimButton.running {
            background-color: #e74c3c;
        }
        #toggleSimButton.running:hover {
            background-color: #c0392b;
        }
    </style>
</head>
<body>
    <h1>Socratic-Quantum Forge: Studio Simulator</h1>
    <div id="simulationContainer">
        <canvas id="simulationCanvas"></canvas>
        <div class="command-bar" id="commandBar">
            <input type="text" id="commandInput">
            <button class="sim-button" id="submitCommandButton">Submit</button>
        </div>
    </div>
    <div id="controls">
        <button class="sim-button" id="toggleSimButton">Start Sim</button>
        <label for="speedControl">Turn Speed:</label>
        <input type="range" id="speedControl" min="1" max="5" value="1">
        <span id="speedValue">1s</span>
    </div>

    <script>
        // --- CORE SETUP ---
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const commandInput = document.getElementById('commandInput');
        const commandBar = document.getElementById('commandBar');
        const submitCommandButton = document.getElementById('submitCommandButton');
        const toggleSimButton = document.getElementById('toggleSimButton');
        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');

        const canvasWidth = 1280;
        const canvasHeight = 720;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // --- SIMULATION CONTROL ---
        let simulationInterval = null;
        let isSimRunning = false;
        let turnIntervalSeconds = 1;
        
        // --- SIMULATION STATE: THE SINGLE SOURCE OF TRUTH ---
        let simulationState = {
            gameState: {
                currentWeek: 1,
                projectName: "Project Chimera",
                budget: 1000000,
                designCompleteness: 0,
                buildProgress: 0,
                bugs: 0,
                marketHype: 0,
                weeklySpend: 5000,
                marketingActive: false,
                gameReleased: false,
                finalScore: 0,
                // FIXED: Pre-load the queue to prevent a dead start
                commandQueue: [
                    "/declare 'Project Chimera' is a third-person action RPG with stealth elements, set in a cyberpunk fantasy world."
                ],
                lastAgentActivity: {
                    translator: "Awaiting input.",
                    inquisitor: "Idle.",
                    producer: "Awaiting project start.",
                    marketing: "Planning phase."
                }
            },
            quantumCore: [],
            unansweredQuestions: [],
        };

        // --- AGENT BEHAVIOR & SIMULATION LOGIC ---

        function generateId(prefix = 'q') {
            return `${prefix}-${Math.random().toString(36).substr(2, 9)}`;
        }

        function translatorTurn(input) {
            simulationState.gameState.lastAgentActivity.translator = `Parsing: "${input.substring(0, 30)}..."`;
            const newQuanta = [];
            const lowerInput = input.toLowerCase();
            if (lowerInput.includes('rpg')) newQuanta.push({ quantumType: 'Genre', data: { name: 'Action RPG' } });
            if (lowerInput.includes('stealth')) newQuanta.push({ quantumType: 'MechanicPillar', data: { name: 'Stealth' } });
            if (lowerInput.includes('cyberpunk')) newQuanta.push({ quantumType: 'Setting', data: { name: 'Cyberpunk Fantasy' } });
            if (lowerInput.includes('protagonist')) newQuanta.push({ quantumType: 'Character', data: { name: 'Unit 734' } });
            if (lowerInput.includes('ghostwire')) newQuanta.push({ quantumType: 'Ability', data: { name: 'Ghostwire' } });
            if (lowerInput.includes('art style')) newQuanta.push({ quantumType: 'ArtStyle', data: { name: 'Dystopian Baroque' }});
            if (lowerInput.includes('gameplay loop')) newQuanta.push({ quantumType: 'GameplayLoop', data: { description: 'Explore, Contract, Takedown, Upgrade' }});

            if (newQuanta.length > 0) {
                newQuanta.forEach(q => {
                    q.quantumId = generateId();
                    q.version = 1;
                    q.status = "Active";
                    q.createdAt = `Week ${simulationState.gameState.currentWeek}`;
                    q.declarationSource = input;
                    simulationState.quantumCore.push(q);
                });
                simulationState.gameState.lastAgentActivity.translator = `Created ${newQuanta.length} new quanta.`;
                return true;
            } else {
                simulationState.gameState.lastAgentActivity.translator = `No new quanta defined.`;
                return false;
            }
        }

        function inquisitorTurn() {
            const newQuestions = [];
            const recentQuanta = simulationState.quantumCore.filter(q => q.createdAt === `Week ${simulationState.gameState.currentWeek}`);
            
            recentQuanta.forEach(q => {
                if (q.quantumType === 'Genre' && !simulationState.unansweredQuestions.some(uq => uq.text.includes('gameplay loop'))) {
                    newQuestions.push({ id: generateId('uq'), text: "What is the core gameplay loop?", status: "Open" });
                }
                if (q.quantumType === 'Character' && !simulationState.unansweredQuestions.some(uq => uq.text.includes('backstory'))) {
                    newQuestions.push({ id: generateId('uq'), text: "What is the protagonist's backstory?", status: "Open" });
                }
                 if (q.quantumType === 'MechanicPillar' && !simulationState.unansweredQuestions.some(uq => uq.text.includes('controls'))) {
                    newQuestions.push({ id: generateId('uq'), text: "How are the stealth mechanics controlled?", status: "Open" });
                }
            });

            if (newQuestions.length > 0) {
                simulationState.unansweredQuestions.push(...newQuestions);
                simulationState.gameState.lastAgentActivity.inquisitor = `Generated ${newQuestions.length} new question(s).`;
            } else {
                 simulationState.gameState.lastAgentActivity.inquisitor = "No new questions needed.";
            }
        }
        
        function producerTurn() {
            // This check is now safe because the queue is pre-loaded
             if (simulationState.quantumCore.length === 0 || simulationState.gameState.gameReleased) {
                simulationState.gameState.lastAgentActivity.producer = 'Idle.';
                return;
            }
            simulationState.gameState.budget -= simulationState.gameState.weeklySpend;
            const openQuestions = simulationState.unansweredQuestions.filter(q => q.status === 'Open').length;
            const progressThisWeek = Math.max(0.5, 5 - openQuestions * 0.5);
            simulationState.gameState.buildProgress = Math.min(100, simulationState.gameState.buildProgress + progressThisWeek);
            const bugsThisWeek = openQuestions;
            simulationState.gameState.bugs += bugsThisWeek;
            simulationState.gameState.lastAgentActivity.producer = `+${progressThisWeek.toFixed(1)}% progress, +${bugsThisWeek} bugs.`;

            if (simulationState.gameState.buildProgress >= 100) {
                releaseGame();
            }
        }

        function marketingTurn() {
            if (!simulationState.gameState.marketingActive || simulationState.gameState.gameReleased) {
                 simulationState.gameState.lastAgentActivity.marketing = 'Planning...';
                 return;
            }
            const hypeThisWeek = simulationState.quantumCore.length / 2;
            simulationState.gameState.marketHype = Math.min(100, simulationState.gameState.marketHype + hypeThisWeek);
            simulationState.gameState.weeklySpend += 2000;
            simulationState.gameState.lastAgentActivity.marketing = `+${hypeThisWeek.toFixed(1)} hype. Campaign is live.`
        }

        // --- FIXED: Regex now correctly looks for "uq-" prefix ---
        function resolveAnswer(input) {
            const questionIdMatch = input.match(/(\/answer\s+)(uq-[a-z0-9]+)/);
            if (questionIdMatch) {
                const questionId = questionIdMatch[2];
                const question = simulationState.unansweredQuestions.find(q => q.id === questionId);
                if (question) {
                    question.status = "Answered";
                    translatorTurn(input); // Also create a quantum from the answer
                    simulationState.gameState.lastAgentActivity.translator = `Answered question ${questionId}.`
                    return true;
                }
            }
            // If the format is wrong, or ID not found, just treat it as a declaration
            translatorTurn(input);
            return false; // Return false as it wasn't a valid answer command
        }

        function advanceWeek() {
            if (simulationState.gameState.gameReleased) {
                if (isSimRunning) toggleSimulation(); // Stop the sim
                return;
            }
            
            const input = simulationState.gameState.commandQueue.shift(); // Get next command from queue
            
            if (input && input.trim() !== '') {
                let processed = false;
                if (input.startsWith('/declare')) {
                    processed = translatorTurn(input);
                } else if (input.startsWith('/answer')) {
                    processed = resolveAnswer(input);
                }
                if (processed) {
                    inquisitorTurn();
                }
            } else {
                 simulationState.gameState.lastAgentActivity.translator = `Awaiting input.`;
                 simulationState.gameState.lastAgentActivity.inquisitor = `Idle.`;
            }

            producerTurn();
            
            if (simulationState.gameState.currentWeek > 5) {
                simulationState.gameState.marketingActive = true;
            }
            marketingTurn();

            simulationState.gameState.currentWeek++;
            
            const openQuestions = simulationState.unansweredQuestions.filter(q => q.status === 'Open').length;
            const totalItems = simulationState.quantumCore.length + openQuestions;
            if (totalItems > 0) {
                 simulationState.gameState.designCompleteness = (simulationState.quantumCore.length / totalItems) * 100;
            } else if (simulationState.quantumCore.length > 0) {
                 simulationState.gameState.designCompleteness = 100;
            }
            
            updatePlaceholder();
            draw();
        }
        
        function updatePlaceholder() {
            const openQuestion = simulationState.unansweredQuestions.find(q => q.status === 'Open');
            if(openQuestion) {
                commandInput.placeholder = `e.g., /answer ${openQuestion.id} ...`;
            } else {
                commandInput.placeholder = "e.g., /declare The main villain is...";
            }
        }

        function releaseGame() {
            simulationState.gameState.gameReleased = true;
            commandBar.style.display = 'none';
            const designScore = simulationState.gameState.designCompleteness;
            const hypeScore = simulationState.gameState.marketHype;
            const qualityScore = Math.max(0, 100 - (simulationState.gameState.bugs * 2));
            simulationState.gameState.finalScore = (designScore * 0.4) + (hypeScore * 0.3) + (qualityScore * 0.3);
            simulationState.gameState.lastAgentActivity.producer = `GAME RELEASED! Final Score: ${simulationState.gameState.finalScore.toFixed(1)}`
        }

        // --- RENDERING ENGINE ---
        
        function drawPanel(x, y, w, h, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.rect(x, y, w, h); ctx.fill(); }
        
        function drawText(text, x, y, size = 16, color = '#ecf0f1', align = 'left', baseline = 'alphabetic') { 
            ctx.fillStyle = color; 
            ctx.font = `bold ${size}px 'Segoe UI'`; 
            ctx.textAlign = align; 
            ctx.textBaseline = baseline;
            ctx.fillText(text, x, y); 
        }
        
        function drawProgressBar(label, x, y, w, h, value, color) {
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(x, y, w, h);
            const fillWidth = (w * value) / 100;
            ctx.fillStyle = color; ctx.fillRect(x, y, fillWidth, h);
            ctx.strokeStyle = '#7f8c8d'; ctx.strokeRect(x, y, w, h);
            const text = `${label}: ${value.toFixed(1)}%`;
            // Add a subtle shadow to the text for readability
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillText(text, x + w / 2 + 1, y + h / 2 + 1);
            drawText(text, x + w / 2, y + h / 2, 14, '#ffffff', 'center', 'middle');
        }

        function draw() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            const margin = 20;
            const colWidth = (canvasWidth - margin * 3) / 2;
            const rowHeight = 120;

            drawPanel(0, 0, canvasWidth, 60, '#1f2b38');
            drawText(simulationState.gameState.projectName, margin, 35, 32, '#e67e22', 'left', 'middle');
            drawText(`Week: ${simulationState.gameState.currentWeek}`, canvasWidth - margin, 35, 32, '#ecf0f1', 'right', 'middle');

            drawPanel(margin, 80, colWidth, rowHeight, '#34495e');
            drawText("Command Hub (Your Turn)", margin + 10, 105, 18, '#bdc3c7');

            const agentPanelX = margin * 2 + colWidth;
            drawPanel(agentPanelX, 80, colWidth, rowHeight, '#34495e');
            drawText("Agent Status", agentPanelX + 10, 105, 18, '#bdc3c7');
            drawText(`- Translator: ${simulationState.gameState.lastAgentActivity.translator}`, agentPanelX + 20, 130, 14, '#dddddd');
            drawText(`- Inquisitor: ${simulationState.gameState.lastAgentActivity.inquisitor}`, agentPanelX + 20, 150, 14, '#dddddd');
            drawText(`- Producer: ${simulationState.gameState.lastAgentActivity.producer}`, agentPanelX + 20, 170, 14, '#dddddd');
            drawText(`- Marketing: ${simulationState.gameState.lastAgentActivity.marketing}`, agentPanelX + 20, 190, 14, '#dddddd');

            const metricsPanelY = 220;
            const metricsPanelHeight = 120;
            drawPanel(margin, metricsPanelY, colWidth, metricsPanelHeight, '#34495e');
            drawText("Core Metrics", margin + 10, metricsPanelY + 25, 18, '#bdc3c7');
            
            const barWidth = 350;
            const barHeight = 25;
            drawProgressBar("Design Completeness", margin + 20, metricsPanelY + 45, barWidth, barHeight, simulationState.gameState.designCompleteness, '#2980b9');
            drawProgressBar("Build Progress", margin + 20, metricsPanelY + 80, barWidth, barHeight, simulationState.gameState.buildProgress, '#27ae60');
            
            const textMetricsX = margin + barWidth + 40;
            drawProgressBar("Market Hype", textMetricsX, metricsPanelY + 45, 180, barHeight, simulationState.gameState.marketHype, '#f1c40f');
            drawText(`Budget: $${simulationState.gameState.budget.toLocaleString()}`, textMetricsX, metricsPanelY + 98, 16, '#2ecc71');
            drawText(`Bugs: ${simulationState.gameState.bugs}`, textMetricsX + 130, metricsPanelY + 98, 16, '#e74c3c');

            const dbPanelY = 360;
            const dbPanelHeight = canvasHeight - dbPanelY - margin;
            drawPanel(margin, dbPanelY, colWidth, dbPanelHeight, '#34495e');
            drawText("Quantum Core (Design Facts)", margin + 10, dbPanelY + 25, 18, '#bdc3c7');
            simulationState.quantumCore.slice(0, 12).forEach((q, i) => {
                const text = `[${q.quantumType}] ${q.data.name || q.data.description || ''}`;
                drawText(text.substring(0,60), margin + 20, dbPanelY + 55 + i * 22, 14, '#ecf0f1');
            });
            
            drawPanel(agentPanelX, dbPanelY, colWidth, dbPanelHeight, '#34495e');
            drawText("Unanswered Questions", agentPanelX + 10, dbPanelY + 25, 18, '#bdc3c7');
            simulationState.unansweredQuestions.slice(0, 12).forEach((uq, i) => {
                drawText(`${uq.id}: ${uq.text.substring(0,50)}`, agentPanelX + 20, dbPanelY + 55 + i * 22, 14, uq.status === 'Open' ? '#e74c3c' : '#2ecc71');
            });

            if (simulationState.gameState.gameReleased) {
                 drawPanel(0, 0, canvasWidth, canvasHeight, 'rgba(44, 62, 80, 0.9)');
                 drawText('GAME RELEASED!', canvasWidth/2, canvasHeight/2 - 50, 60, '#e67e22', 'center');
                 drawText(`Final Score: ${simulationState.gameState.finalScore.toFixed(1)} / 100`, canvasWidth/2, canvasHeight/2 + 20, 40, '#ecf0f1', 'center');
                 drawText('Refresh the page to start a new project.', canvasWidth/2, canvasHeight/2 + 80, 20, '#bdc3c7', 'center');
            }
        }

        // --- INTERACTION HANDLING ---
        function submitCommand() {
            const command = commandInput.value;
            if (command.trim() !== '') {
                simulationState.gameState.commandQueue.push(command);
                commandInput.value = '';
            }
        }

        function toggleSimulation() {
            isSimRunning = !isSimRunning;
            if (isSimRunning) {
                toggleSimButton.textContent = 'Stop Sim';
                toggleSimButton.classList.add('running');
                simulationInterval = setInterval(advanceWeek, turnIntervalSeconds * 1000);
            } else {
                toggleSimButton.textContent = 'Start Sim';
                toggleSimButton.classList.remove('running');
                clearInterval(simulationInterval);
            }
        }

        function updateSpeed() {
            turnIntervalSeconds = speedControl.value;
            speedValue.textContent = `${turnIntervalSeconds}s`;
            if (isSimRunning) { // If running, restart the interval with the new speed
                clearInterval(simulationInterval);
                simulationInterval = setInterval(advanceWeek, turnIntervalSeconds * 1000);
            }
        }

        function initialize() {
            const margin = 20;
            const colWidth = (canvasWidth - margin * 3) / 2;
            
            commandBar.style.left = `${margin + 10}px`;
            commandBar.style.top = `${125}px`;
            commandInput.style.width = `${colWidth - 140}px`;
            
            submitCommandButton.addEventListener('click', submitCommand);
            commandInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') submitCommand(); });
            toggleSimButton.addEventListener('click', toggleSimulation);
            speedControl.addEventListener('input', updateSpeed);
            
            updatePlaceholder();
            draw();
        };
        
        async function queryAgent(systemPrompt, userPrompt) {
        const endpoint = "http://localhost:1234/v1/chat/completions";

        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: "local-model", // This field is ignored by LM Studio but good practice
                    messages: [
                        { role: "system", content: systemPrompt },
                        { role: "user", content: userPrompt }
                    ],
                    temperature: 0.7,
                })
            });

            if (!response.ok) {
                console.error("API call failed:", response.status);
                return "Error: Could not reach the agent.";
            }

            const data = await response.json();
            return data.choices[0].message.content;

            } catch (error) {
                console.error("Failed to connect to LM Studio. Is the server running?", error);
                // Provide a fallback so the UI doesn't crash
                return "Fallback: The agent is offline.";
            }
        }

        window.onload = initialize;

    </script>
</body>
</html>
