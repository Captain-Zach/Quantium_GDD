// --- CORE SETUP ---
// Get references to all necessary DOM elements
const canvas = document.getElementById('simulationCanvas');
const ctx = canvas.getContext('2d');
const commandInput = document.getElementById('commandInput');
const commandBar = document.getElementById('commandBar');
const submitCommandButton = document.getElementById('submitCommandButton');
const toggleSimButton = document.getElementById('toggleSimButton');
const speedControl = document.getElementById('speedControl');
const speedValue = document.getElementById('speedValue');

// Set canvas dimensions
const canvasWidth = 1280;
const canvasHeight = 720;
canvas.width = canvasWidth;
canvas.height = canvasHeight;

// --- SIMULATION CONTROL ---
let simulationInterval = null; // To hold the interval ID for starting/stopping the sim
let isSimRunning = false;
let turnIntervalSeconds = 1; // Default speed: 1 second per turn

// --- SIMULATION STATE: THE SINGLE SOURCE OF TRUTH ---
// All data related to the current game simulation is stored here.
let simulationState = {
    gameState: {
        currentWeek: 1,
        projectName: "Project Chimera",
        budget: 1000000,
        designCompleteness: 0,
        buildProgress: 0,
        bugs: 0,
        marketHype: 0,
        weeklySpend: 5000,
        marketingActive: false,
        gameReleased: false,
        finalScore: 0,
        // Pre-load the queue with an initial command to prevent a dead start
        commandQueue: [
            "/declare 'Project Chimera' is a third-person action RPG with stealth elements, set in a cyberpunk fantasy world."
        ],
        lastAgentActivity: {
            translator: "Awaiting input.",
            inquisitor: "Idle.",
            producer: "Awaiting project start.",
            marketing: "Planning phase."
        }
    },
    quantumCore: [], // Holds all the defined design facts (quanta)
    unansweredQuestions: [], // Holds all questions generated by the Inquisitor
};

// --- AGENT BEHAVIOR & SIMULATION LOGIC ---

/**
 * Generates a unique ID string.
 * @param {string} prefix - A prefix for the ID (e.g., 'q' for quantum, 'uq' for question).
 * @returns {string} A unique ID.
 */
function generateId(prefix = 'q') {
    return `${prefix}-${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * The Translator agent's turn. Parses user input to create new design quanta.
 * @param {string} input - The user's command string.
 * @returns {boolean} True if new quanta were created, false otherwise.
 */
function translatorTurn(input) {
    simulationState.gameState.lastAgentActivity.translator = `Parsing: "${input.substring(0, 30)}..."`;
    const newQuanta = [];
    const lowerInput = input.toLowerCase();

    // Simple keyword-based parsing to create design quanta
    if (lowerInput.includes('rpg')) newQuanta.push({ quantumType: 'Genre', data: { name: 'Action RPG' } });
    if (lowerInput.includes('stealth')) newQuanta.push({ quantumType: 'MechanicPillar', data: { name: 'Stealth' } });
    if (lowerInput.includes('cyberpunk')) newQuanta.push({ quantumType: 'Setting', data: { name: 'Cyberpunk Fantasy' } });
    if (lowerInput.includes('protagonist')) newQuanta.push({ quantumType: 'Character', data: { name: 'Unit 734' } });
    if (lowerInput.includes('ghostwire')) newQuanta.push({ quantumType: 'Ability', data: { name: 'Ghostwire' } });
    if (lowerInput.includes('art style')) newQuanta.push({ quantumType: 'ArtStyle', data: { name: 'Dystopian Baroque' }});
    if (lowerInput.includes('gameplay loop')) newQuanta.push({ quantumType: 'GameplayLoop', data: { description: 'Explore, Contract, Takedown, Upgrade' }});

    if (newQuanta.length > 0) {
        newQuanta.forEach(q => {
            q.quantumId = generateId();
            q.version = 1;
            q.status = "Active";
            q.createdAt = `Week ${simulationState.gameState.currentWeek}`;
            q.declarationSource = input;
            simulationState.quantumCore.push(q);
        });
        simulationState.gameState.lastAgentActivity.translator = `Created ${newQuanta.length} new quanta.`;
        return true;
    } else {
        simulationState.gameState.lastAgentActivity.translator = `No new quanta defined.`;
        return false;
    }
}

/**
 * The Inquisitor agent's turn. Scans for missing information and generates questions.
 */
function inquisitorTurn() {
    const newQuestions = [];
    const recentQuanta = simulationState.quantumCore.filter(q => q.createdAt === `Week ${simulationState.gameState.currentWeek}`);
    
    recentQuanta.forEach(q => {
        if (q.quantumType === 'Genre' && !simulationState.unansweredQuestions.some(uq => uq.text.includes('gameplay loop'))) {
            newQuestions.push({ id: generateId('uq'), text: "What is the core gameplay loop?", status: "Open" });
        }
        if (q.quantumType === 'Character' && !simulationState.unansweredQuestions.some(uq => uq.text.includes('backstory'))) {
            newQuestions.push({ id: generateId('uq'), text: "What is the protagonist's backstory?", status: "Open" });
        }
         if (q.quantumType === 'MechanicPillar' && !simulationState.unansweredQuestions.some(uq => uq.text.includes('controls'))) {
            newQuestions.push({ id: generateId('uq'), text: "How are the stealth mechanics controlled?", status: "Open" });
        }
    });

    if (newQuestions.length > 0) {
        simulationState.unansweredQuestions.push(...newQuestions);
        simulationState.gameState.lastAgentActivity.inquisitor = `Generated ${newQuestions.length} new question(s).`;
    } else {
         simulationState.gameState.lastAgentActivity.inquisitor = "No new questions needed.";
    }
}

/**
 * The Producer agent's turn. Manages budget, progress, and bugs.
 */
function producerTurn() {
    if (simulationState.quantumCore.length === 0 || simulationState.gameState.gameReleased) {
        simulationState.gameState.lastAgentActivity.producer = 'Idle.';
        return;
    }
    // Update budget and progress
    simulationState.gameState.budget -= simulationState.gameState.weeklySpend;
    const openQuestions = simulationState.unansweredQuestions.filter(q => q.status === 'Open').length;
    const progressThisWeek = Math.max(0.5, 5 - openQuestions * 0.5); // Progress slows with more open questions
    simulationState.gameState.buildProgress = Math.min(100, simulationState.gameState.buildProgress + progressThisWeek);
    
    // Generate bugs based on ambiguity (open questions)
    const bugsThisWeek = openQuestions;
    simulationState.gameState.bugs += bugsThisWeek;
    simulationState.gameState.lastAgentActivity.producer = `+${progressThisWeek.toFixed(1)}% progress, +${bugsThisWeek} bugs.`;

    // Check if the game is ready to be released
    if (simulationState.gameState.buildProgress >= 100) {
        releaseGame();
    }
}

/**
 * The Marketing agent's turn. Builds hype for the game.
 */
function marketingTurn() {
    if (!simulationState.gameState.marketingActive || simulationState.gameState.gameReleased) {
         simulationState.gameState.lastAgentActivity.marketing = 'Planning...';
         return;
    }
    const hypeThisWeek = simulationState.quantumCore.length / 2; // Hype is based on design depth
    simulationState.gameState.marketHype = Math.min(100, simulationState.gameState.marketHype + hypeThisWeek);
    simulationState.gameState.weeklySpend += 2000; // Marketing costs money
    simulationState.gameState.lastAgentActivity.marketing = `+${hypeThisWeek.toFixed(1)} hype. Campaign is live.`
}

/**
 * Processes an '/answer' command, linking it to an open question.
 * @param {string} input - The user's answer command.
 * @returns {boolean} True if a question was successfully answered.
 */
function resolveAnswer(input) {
    const questionIdMatch = input.match(/(\/answer\s+)(uq-[a-z0-9]+)/);
    if (questionIdMatch) {
        const questionId = questionIdMatch[2];
        const question = simulationState.unansweredQuestions.find(q => q.id === questionId);
        if (question) {
            question.status = "Answered";
            translatorTurn(input); // Also create a quantum from the answer's content
            simulationState.gameState.lastAgentActivity.translator = `Answered question ${questionId}.`
            return true;
        }
    }
    // If the format is wrong or ID not found, just treat it as a declaration
    translatorTurn(input);
    return false;
}

/**
 * Advances the simulation by one week, triggering all agent turns.
 */
function advanceWeek() {
    if (simulationState.gameState.gameReleased) {
        if (isSimRunning) toggleSimulation(); // Stop the sim if the game is released
        return;
    }
    
    // Process one command from the queue
    const input = simulationState.gameState.commandQueue.shift(); 
    
    if (input && input.trim() !== '') {
        let processed = false;
        if (input.startsWith('/declare')) {
            processed = translatorTurn(input);
        } else if (input.startsWith('/answer')) {
            processed = resolveAnswer(input);
        }
        // The Inquisitor only runs if the Translator did something
        if (processed) {
            inquisitorTurn();
        }
    } else {
         simulationState.gameState.lastAgentActivity.translator = `Awaiting input.`;
         simulationState.gameState.lastAgentActivity.inquisitor = `Idle.`;
    }

    // Run the other agents
    producerTurn();
    
    // Activate marketing after a few weeks
    if (simulationState.gameState.currentWeek > 5) {
        simulationState.gameState.marketingActive = true;
    }
    marketingTurn();

    simulationState.gameState.currentWeek++;
    
    // Update design completeness metric
    const openQuestions = simulationState.unansweredQuestions.filter(q => q.status === 'Open').length;
    const totalItems = simulationState.quantumCore.length + openQuestions;
    if (totalItems > 0) {
         simulationState.gameState.designCompleteness = (simulationState.quantumCore.length / totalItems) * 100;
    } else if (simulationState.quantumCore.length > 0) {
         simulationState.gameState.designCompleteness = 100;
    }
    
    updatePlaceholder();
    draw(); // Redraw the screen with the new state
}

/**
 * Updates the placeholder text in the command input to guide the user.
 */
function updatePlaceholder() {
    const openQuestion = simulationState.unansweredQuestions.find(q => q.status === 'Open');
    if(openQuestion) {
        commandInput.placeholder = `e.g., /answer ${openQuestion.id} ...`;
    } else {
        commandInput.placeholder = "e.g., /declare The main villain is...";
    }
}

/**
 * Finalizes the game, calculates the score, and displays the end screen.
 */
function releaseGame() {
    simulationState.gameState.gameReleased = true;
    commandBar.style.display = 'none'; // Hide the input
    
    // Calculate final score based on different metrics
    const designScore = simulationState.gameState.designCompleteness;
    const hypeScore = simulationState.gameState.marketHype;
    const qualityScore = Math.max(0, 100 - (simulationState.gameState.bugs * 2)); // Bugs heavily penalize score
    simulationState.gameState.finalScore = (designScore * 0.4) + (hypeScore * 0.3) + (qualityScore * 0.3);
    
    simulationState.gameState.lastAgentActivity.producer = `GAME RELEASED! Final Score: ${simulationState.gameState.finalScore.toFixed(1)}`
}

// --- RENDERING ENGINE ---
// A collection of functions to draw elements on the canvas.

function drawPanel(x, y, w, h, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.rect(x, y, w, h); ctx.fill(); }

function drawText(text, x, y, size = 16, color = '#ecf0f1', align = 'left', baseline = 'alphabetic') { 
    ctx.fillStyle = color; 
    ctx.font = `bold ${size}px 'Segoe UI'`; 
    ctx.textAlign = align; 
    ctx.textBaseline = baseline;
    ctx.fillText(text, x, y); 
}

function drawProgressBar(label, x, y, w, h, value, color) {
    ctx.fillStyle = '#1a1a1a'; ctx.fillRect(x, y, w, h);
    const fillWidth = (w * value) / 100;
    ctx.fillStyle = color; ctx.fillRect(x, y, fillWidth, h);
    ctx.strokeStyle = '#7f8c8d'; ctx.strokeRect(x, y, w, h);
    const text = `${label}: ${value.toFixed(1)}%`;
    // Add a subtle shadow to the text for readability
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillText(text, x + w / 2 + 1, y + h / 2 + 1);
    drawText(text, x + w / 2, y + h / 2, 14, '#ffffff', 'center', 'middle');
}

/**
 * Main drawing function. Clears and redraws the entire canvas based on the current simulationState.
 */
function draw() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    const margin = 20;
    const colWidth = (canvasWidth - margin * 3) / 2;
    const rowHeight = 120;

    // Header
    drawPanel(0, 0, canvasWidth, 60, '#1f2b38');
    drawText(simulationState.gameState.projectName, margin, 35, 32, '#e67e22', 'left', 'middle');
    drawText(`Week: ${simulationState.gameState.currentWeek}`, canvasWidth - margin, 35, 32, '#ecf0f1', 'right', 'middle');

    // Command Hub Panel (where the input field is located)
    drawPanel(margin, 80, colWidth, rowHeight, '#34495e');
    drawText("Command Hub (Your Turn)", margin + 10, 105, 18, '#bdc3c7');

    // Agent Status Panel
    drawPanel(margin * 2 + colWidth, 80, colWidth, rowHeight, '#34495e');
    drawText("Agent Status", margin * 2 + colWidth + 10, 105, 18, '#bdc3c7');
    drawText(`- Translator: ${simulationState.gameState.lastAgentActivity.translator}`, margin * 2 + colWidth + 20, 130, 14, '#dddddd');
    drawText(`- Inquisitor: ${simulationState.gameState.lastAgentActivity.inquisitor}`, margin * 2 + colWidth + 20, 150, 14, '#dddddd');
    drawText(`- Producer: ${simulationState.gameState.lastAgentActivity.producer}`, margin * 2 + colWidth + 20, 170, 14, '#dddddd');
    drawText(`- Marketing: ${simulationState.gameState.lastAgentActivity.marketing}`, margin * 2 + colWidth + 20, 190, 14, '#dddddd');

    // Core Metrics Panel
    const metricsPanelY = 220;
    const metricsPanelHeight = 120;
    drawPanel(margin, metricsPanelY, colWidth, metricsPanelHeight, '#34495e');
    drawText("Core Metrics", margin + 10, metricsPanelY + 25, 18, '#bdc3c7');
    const barWidth = 350;
    const barHeight = 25;
    drawProgressBar("Design Completeness", margin + 20, metricsPanelY + 45, barWidth, barHeight, simulationState.gameState.designCompleteness, '#2980b9');
    drawProgressBar("Build Progress", margin + 20, metricsPanelY + 80, barWidth, barHeight, simulationState.gameState.buildProgress, '#27ae60');
    const textMetricsX = margin + barWidth + 40;
    drawProgressBar("Market Hype", textMetricsX, metricsPanelY + 45, 180, barHeight, simulationState.gameState.marketHype, '#f1c40f');
    drawText(`Budget: $${simulationState.gameState.budget.toLocaleString()}`, textMetricsX, metricsPanelY + 98, 16, '#2ecc71');
    drawText(`Bugs: ${simulationState.gameState.bugs}`, textMetricsX + 130, metricsPanelY + 98, 16, '#e74c3c');

    // Quantum Core Panel
    const dbPanelY = 360;
    const dbPanelHeight = canvasHeight - dbPanelY - margin;
    drawPanel(margin, dbPanelY, colWidth, dbPanelHeight, '#34495e');
    drawText("Quantum Core (Design Facts)", margin + 10, dbPanelY + 25, 18, '#bdc3c7');
    simulationState.quantumCore.slice(0, 12).forEach((q, i) => {
        const text = `[${q.quantumType}] ${q.data.name || q.data.description || ''}`;
        drawText(text.substring(0,60), margin + 20, dbPanelY + 55 + i * 22, 14, '#ecf0f1');
    });
    
    // Unanswered Questions Panel
    drawPanel(margin * 2 + colWidth, dbPanelY, colWidth, dbPanelHeight, '#34495e');
    drawText("Unanswered Questions", margin * 2 + colWidth + 10, dbPanelY + 25, 18, '#bdc3c7');
    simulationState.unansweredQuestions.slice(0, 12).forEach((uq, i) => {
        drawText(`${uq.id}: ${uq.text.substring(0,50)}`, margin * 2 + colWidth + 20, dbPanelY + 55 + i * 22, 14, uq.status === 'Open' ? '#e74c3c' : '#2ecc71');
    });

    // Game Release Overlay
    if (simulationState.gameState.gameReleased) {
         drawPanel(0, 0, canvasWidth, canvasHeight, 'rgba(44, 62, 80, 0.9)');
         drawText('GAME RELEASED!', canvasWidth/2, canvasHeight/2 - 50, 60, '#e67e22', 'center');
         drawText(`Final Score: ${simulationState.gameState.finalScore.toFixed(1)} / 100`, canvasWidth/2, canvasHeight/2 + 20, 40, '#ecf0f1', 'center');
         drawText('Refresh the page to start a new project.', canvasWidth/2, canvasHeight/2 + 80, 20, '#bdc3c7', 'center');
    }
}

// --- INTERACTION HANDLING ---

/**
 * Submits the command from the input field to the command queue.
 */
function submitCommand() {
    const command = commandInput.value;
    if (command.trim() !== '') {
        simulationState.gameState.commandQueue.push(command);
        commandInput.value = '';
    }
}

/**
 * Toggles the main simulation loop on and off.
 */
function toggleSimulation() {
    isSimRunning = !isSimRunning;
    if (isSimRunning) {
        toggleSimButton.textContent = 'Stop Sim';
        toggleSimButton.classList.add('running');
        simulationInterval = setInterval(advanceWeek, turnIntervalSeconds * 1000);
    } else {
        toggleSimButton.textContent = 'Start Sim';
        toggleSimButton.classList.remove('running');
        clearInterval(simulationInterval);
    }
}

/**
 * Updates the turn speed based on the slider and restarts the interval if it's running.
 */
function updateSpeed() {
    turnIntervalSeconds = speedControl.value;
    speedValue.textContent = `${turnIntervalSeconds}s`;
    if (isSimRunning) { // If running, restart the interval with the new speed
        clearInterval(simulationInterval);
        simulationInterval = setInterval(advanceWeek, turnIntervalSeconds * 1000);
    }
}

/**
 * Initializes the application, positions elements, and sets up event listeners.
 */
function initialize() {
    // Position the command bar dynamically based on canvas layout
    const margin = 20;
    const colWidth = (canvasWidth - margin * 3) / 2;
    commandBar.style.left = `${margin + 10}px`;
    commandBar.style.top = `${125}px`;
    commandInput.style.width = `${colWidth - 140}px`;
    
    // Add all event listeners
    submitCommandButton.addEventListener('click', submitCommand);
    commandInput.addEventListener('keypress', (e) => { if(e.key === 'Enter') submitCommand(); });
    toggleSimButton.addEventListener('click', toggleSimulation);
    speedControl.addEventListener('input', updateSpeed);
    
    // Initial setup
    updatePlaceholder();
    draw();
};

/**
 * (Future Use) Asynchronous function to query a local AI model.
 * NOTE: This is not used by the core simulation loop in this version.
 */
async function queryAgent(systemPrompt, userPrompt) {
    const endpoint = "http://localhost:1234/v1/chat/completions";

    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: "local-model", // This field is ignored by LM Studio but good practice
                messages: [
                    { role: "system", content: systemPrompt },
                    { role: "user", content: userPrompt }
                ],
                temperature: 0.7,
            })
        });

        if (!response.ok) {
            console.error("API call failed:", response.status);
            return "Error: Could not reach the agent.";
        }

        const data = await response.json();
        return data.choices[0].message.content;

    } catch (error) {
        console.error("Failed to connect to LM Studio. Is the server running?", error);
        // Provide a fallback so the UI doesn't crash
        return "Fallback: The agent is offline.";
    }
}

// Run the initialize function once the page's main content has loaded.
window.onload = initialize;
